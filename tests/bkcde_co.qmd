---
title: "Benchmarking bkcde Core Tuning"
author: "Generated by GitHub Copilot"
date: "2026-01-25"
format:
  html: default
  pdf: default
---

# Overview

This document benchmarks the performance of the default and tuned core allocations in the `bkcde` package using simulated data. The tuning is performed with `bkcdeco`, and timing comparisons are made using the `microbenchmark` package. Both mean and median speedups are reported.

```{r}
#| label: setup
#| echo: false
#| include: false
library(microbenchmark)
library(bkcde)
```

```{r}
#| label: simulate-run
#| echo: false
#| warning: false
#| cache: true
set.seed(42)
n <- 100
x <- runif(n, 0, 1)
y <- rnorm(n, mean = 2 * sin(4 * pi * x), sd = 1 + abs(x))

# Benchmark core allocations with a small grid
res <- bkcdeco(x, y,
               optim.degree.cores.min = 1,
               optim.degree.cores.max = 6,
               optim.nmulti.cores.min = 1,
               optim.nmulti.cores.max = 6,
               optim.ksum.cores.min = 1,
               optim.ksum.cores.max = 2,
               fitted.cores.max = 6,
               proper.cores.max = 6,
               progress = FALSE,
               display.warnings = FALSE)
```


This simulation is based on $n = `r n`$ data points, with $x$ uniformly distributed in [0, 1] and $y$ generated from a sinusoidal function with added noise. 

```{r}
#| label: microbench
#| echo: false
#| warning: false
#| cache: true
timing_results <- microbenchmark(
  default = {
    f.yx.default <- bkcde(x = x, y = y,
                          bwmethod = "cv.ml",
                          proper = TRUE,
                          display.warnings = FALSE)
  },
  tuned = {
    f.yx.tuned <- bkcde(x = x, y = y,
                        bwmethod = "cv.ml",
                        optim.cores = "manual",
                        optim.degree.cores = res$best.optim$optim.degree.cores,
                        optim.nmulti.cores = res$best.optim$optim.nmulti.cores,
                        optim.ksum.cores = res$best.optim$optim.ksum.cores,
                        fitted.cores = res$best.fitted$fitted.cores,
                        proper = TRUE,
                        proper.cores = res$best.proper$proper.cores,
                        display.warnings = FALSE)
  },
  times = 10 # Adjust as needed
)

# Extract mean and median times (in seconds)
mean_default <- mean(timing_results$time[timing_results$expr == "default"]) / 1e9
mean_tuned   <- mean(timing_results$time[timing_results$expr == "tuned"]) / 1e9
median_default <- median(timing_results$time[timing_results$expr == "default"]) / 1e9
median_tuned   <- median(timing_results$time[timing_results$expr == "tuned"]) / 1e9

# Calculate speedup
mean_speedup <- mean_default / mean_tuned
median_speedup <- median_default / median_tuned
```

```{r}
#| label: tbl-summary-table-final
#| echo: false
#| message: false
#| warning: false

# Helper to extract value or NA if not present
extract_val <- function(obj, name) {
  if (!is.null(obj) && !is.null(obj[[name]])) obj[[name]] else NA
}

library(knitr)
library(kableExtra)

# Data Preparation
formatted_table <- data.frame(
  Metric = c(
    "Degree Cores", "Nmulti Cores", "Ksum Cores", "Fitted Cores", "Proper Cores",
    "Time (res, sec)", "Time (mean, sec)", "Time (median, sec)"
  ),
  Default = c(
    extract_val(f.yx.default, "optim.degree.cores"),
    extract_val(f.yx.default, "optim.nmulti.cores"),
    extract_val(f.yx.default, "optim.ksum.cores"),
    extract_val(f.yx.default, "fitted.cores"),
    extract_val(f.yx.default, "proper.cores"),
    sprintf("%.4f", as.numeric(res$default_total)),
    sprintf("%.4f", mean_default),
    sprintf("%.4f", median_default)
  ),
  Tuned = c(
    extract_val(f.yx.tuned, "optim.degree.cores"),
    extract_val(f.yx.tuned, "optim.nmulti.cores"),
    extract_val(f.yx.tuned, "optim.ksum.cores"),
    extract_val(f.yx.tuned, "fitted.cores"),
    extract_val(f.yx.tuned, "proper.cores"),
    sprintf("%.4f", as.numeric(res$tuned_total)),
    sprintf("%.4f", mean_tuned),
    sprintf("%.4f", median_tuned)
  )
)

# Table Generation

kable(formatted_table, 
      col.names = c("Metric", "Default", "Tuned"),
      caption = "Parallel Processing Optimization: Core Allocation and Benchmarking",
      align = "lrr",
      booktabs = TRUE) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                full_width = FALSE, 
                position = "center",
                latex_options = c("hold_position")) %>%
  add_header_above(c(" " = 1, "Model Configuration" = 2)) %>%
  pack_rows("Core Allocations", 1, 5) %>%
  pack_rows("Timing Performance", 6, 8) %>%
  column_spec(3, bold = TRUE) %>% 
  footnote(
    general_title = "Optimization Summary:",
    general = paste0(
      "The optimizer achieved a ", sprintf("%.2fx", mean_speedup), 
      " mean speedup. Simulated results (res) predicted ", 
      sprintf("%.2fx", as.numeric(res$speedup)), "."
    ),
    footnote_as_chunk = FALSE, # This ensures the text spans the table width
    threeparttable = TRUE      # Ensures the footer doesn't exceed table width in PDF
  )  
```

